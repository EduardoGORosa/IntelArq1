Microsoft (R) Macro Assembler Version 6.11		    09/07/23 03:03:55
trabalho.asm						     Page 1 - 1


				;             Trabalho Intel
				;
				;         Eduardo Rosa   00335503

				.model small
				.stack

 0000				.data
				ORG 80H             
 0080 00			CMDCNT DB ?          ;COMMAND LINE COUNT
 0081  007F [			CMDSTR DB 127 DUP(?)  ;COMMAND LINE BUFFER
        00
       ]
				;--------------------------------------------
				; DATA
				;--------------------------------------------
 = 000D				CR					      equ		0dh
 = 000A				LF					      equ		0ah

 0100  007F [			cmdline              db    127   dup(?)
        00
       ]
 017F  0032 [			inputFile            db    50    dup(?)        ; Nome do arquivo de entrada
        00
       ]
 01B1  0032 [			outputFile           db    50    dup(?)        ; Nome padrão do arquivo de saída
        00
       ]
 01E3 61 2E 6F 75 74 00		defaultOutputFile    db    'a.out', 0       ; Nome padrão do arquivo de saída
 01E9  0005 [			groupSize            db    5     dup(?)               ; Tamanho do grupo de bases
        00
       ]
 01EE  0005 [			nitrogen_bases       db    5     dup(?)
        00
       ]
 01F3 00			base_a               db    0
 01F4 00			base_c               db    0
 01F5 00			base_t               db    0
 01F6 00			base_g               db    0
 01F7 00			base_plus            db    0
 01F8 61 63 74 67 2B 00		base_valid           db    "actg+", 0
 01FE 45 72 72 6F 20 6E		errorCommandLineMsg	db		"Erro na escrita da linha de comando", CR, LF, 0
       61 20 65 73 63 72
       69 74 61 20 64 61
       20 6C 69 6E 68 61
       20 64 65 20 63 6F
       6D 61 6E 64 6F 0D
       0A 00
 0224 00			flagError				db		0
 0225 0D 0A 00			MsgCRLF					db		CR, LF, 0
				;--------------------------------------------
				;SCAN INPUT PARAMETER LINE

 0000				.code
				.startup
 0017  BE 0081			   mov      si, 81h
 001A  B5 00			   mov      ch,0
 001C  26: 8A 0E 0080		   mov      cl,es:[80h]      ;PARAMETER COUNT by variable CMDCNT
 0021  83 F9 00			   cmp      cx,0
 0024  75 03			   jnz      parse_command_line          ;YES - PROCESS COMMAND LINE PARAMETERS
 0026  E9 012F			   jmp      no_arguments           ;NO - PARAMETERS
				   
 0029				parse_command_line:   
 0029				   skip_space:
 0029  26: 8A 04		      mov   al, es:[si]
 002C  3C 20			      cmp   al, ' '
 002E  74 0A			      je    next_option
 0030  3C 0D			      cmp   al, CR
 0032  75 03 E9 0121		      je    no_arguments
 0037  46			      inc   si
 0038  EB EF			      jmp   skip_space
				   
 003A				   next_option:
 003A  46			      inc   si
 003B  26: 8A 04		      mov   al, es:[si]

				      ; Verificar se encontramos uma opção válida
 003E  3C 2D			      cmp   al, '-'
 0040  74 03 E9 0104		      jne   invalid_option

						; Move string pointer
 0045  46					inc   si
 0046  26: 8A 04				mov   al, es:[si]
 0049  3C 0D			      cmp   al, CR
 004B  75 03 E9 00F9		      je    invalid_option
 0050  3C 66					cmp   al, 'f'
 0052  74 0A			      je    f_option
 0054  3C 6F					cmp   al, 'o'
 0056  74 26			      je    o_option
 0058  3C 6E					cmp   al, 'n'
 005A  74 42			      je    n_option
 005C  EB 75			      jmp   base_option

 005E				   f_option:
 005E  8D 3E 017F R		      lea   di, inputFile
 0062  46			      inc   si
 0063  26: 8A 04		      mov   al, es:[si]
 0066  3C 20			      cmp   al, ' '
 0068  74 03 E9 00DC		      jne   invalid_option
 006D				      f_option_loop:
 006D  46			         inc   si
 006E  26: 8A 04		         mov   al, es:[si]
 0071  3C 20			         cmp   al, ' '
 0073  74 B4			         je    skip_space
 0075  3C 0D			         cmp   al, CR
 0077  74 B0			         je    skip_space
 0079  88 05			         mov   [di], al
 007B  47			         inc   di
 007C  EB EF			         jmp   f_option_loop 

 007E					o_option:
 007E  8D 3E 01B1 R		      lea   di, outputFile
 0082  46			      inc   si
 0083  26: 8A 04		      mov   al, es:[si]
 0086  3C 20			      cmp   al, ' '
 0088  74 03 E9 00BC		      jne   invalid_option
 008D				      o_option_loop:
 008D  46			         inc   si
 008E  26: 8A 04		         mov   al, es:[si]
 0091  3C 20			         cmp   al, ' '
 0093  74 94			         je    skip_space
 0095  3C 0D			         cmp   al, CR
 0097  74 90			         je    skip_space
 0099  88 05			         mov   [di], al
 009B  47			         inc   di
 009C  EB EF			         jmp   o_option_loop 

 009E					n_option:
 009E  8D 3E 01E9 R		      lea   di, groupSize
 00A2  46			      inc   si
 00A3  26: 8A 04		      mov   al, es:[si]
 00A6  3C 20			      cmp   al, ' '
 00A8  74 03 E9 009C		      jne   invalid_option
 00AD				      n_option_loop:
 00AD  46			         inc   si
 00AE  26: 8A 04		         mov   al, es:[si]
 00B1  3C 20			         cmp   al, ' '
 00B3  74 17			         je    end_n_option
 00B5  3C 0D			         cmp   al, CR
 00B7  74 13			         je    end_n_option
 00B9  3C 39			         cmp   al, 39h
 00BB  7E 03 E9 0089		         jg    invalid_option
 00C0  3C 30			         cmp   al, 30h
 00C2  7D 03 E9 0082		         jl    invalid_option
 00C7  88 05			         mov   [di], al
 00C9  47			         inc   di
 00CA  EB E1			         jmp   n_option_loop
 00CC				      end_n_option:
 00CC  C7 05 0000		         mov   [di], 0
 00D0  E9 FF56			         jmp   skip_space

 00D3					base_option:
 00D3  8D 3E 01F8 R		      lea   di, base_valid    ; di = base_valid initial adress
 00D7  8D 1E 01EE R		      lea   bx, nitrogen_bases
 00DB  3C 20			      cmp   al, ' '           ; if space invalid
 00DD  74 6A			      je    invalid_option
 00DF  3C 0D			      cmp   al, CR            ; if cr invalid
 00E1  74 66			      je    invalid_option
 00E3				   base_check_loop:
 00E3  26: 8A 04		      mov   al, es:[si]       ; al = cmdline char
 00E6  3C 20			      cmp   al, ' '           ; if space base_cmd ended
 00E8  74 50			      je    done_parsing_base
 00EA  3C 0D			      cmp   al, CR            ; if cr base_cmd ended
 00EC  74 4C			      je    done_parsing_base             
 00EE				   search_loop:
 00EE  3A 05			      cmp   al, [di]       ; if cmdline char == base_valid initial address
 00F0  74 0A			      je    char_is_valid     ; char_is_valid()
 00F2  47			      inc   di                ; base_address++
 00F3  8A 0D			      mov   cl, [di]                ; base_address++
 00F5  80 F9 00			      cmp   cl, 0             ; if base_address == 0
 00F8  75 F4			      jne   search_loop       ; search_loop()
 00FA  EB 40			      jmp   invalid_base_option
				      
 00FC				   char_is_valid:
 00FC  3C 61			      cmp   al, 'a'           ; if cmdline char == 'a'
 00FE  74 12			      je    put_a             ; base_a = True
 0100  3C 63			      cmp   al, 'c'           ; if cmdline char == 'c'
 0102  74 16			      je    put_c             ; base_c = True
 0104  3C 74			      cmp   al, 't'           ; if cmdline char == 't'
 0106  74 1A			      je    put_t             ; base_t = True
 0108  3C 67			      cmp   al, 'g'           ; if cmdline char == 'g'
 010A  74 1E			      je    put_g             ; base_g = True
 010C  3C 2B			      cmp   al, '+'           ; if cmdline char == '+'
 010E  74 22			      je    put_plus          ; base_plus = True
 0110  EB D1			      jmp   base_check_loop

 0112				      put_a: 
 0112  C7 07 0061		         mov   [bx], 'a'
 0116  43			         inc   bx
 0117  46			         inc   si
 0118  EB C9			         jmp   base_check_loop   
 011A				      put_c: 
 011A  C7 07 0063		         mov   [bx], 'c'
 011E  43			         inc   bx
 011F  46			         inc   si
 0120  EB C1			         jmp   base_check_loop   
 0122				      put_t: 
 0122  C7 07 0074		         mov   [bx], 't'
 0126  43			         inc   bx
 0127  46			         inc   si
 0128  EB B9			         jmp   base_check_loop   
 012A				      put_g: 
 012A  C7 07 0067		         mov   [bx], 'g'
 012E  43			         inc   bx
 012F  46			         inc   si
 0130  EB B1			         jmp   base_check_loop   
 0132				      put_plus: 
 0132  C7 07 002B		         mov   [bx], '+'
 0136  43			         inc   bx
 0137  46			         inc   si
 0138  EB A9			         jmp   base_check_loop      

 013A				    done_parsing_base:
 013A  EB 1C			         jmp   no_arguments                                                     

 013C				   invalid_base_option:
 013C  B9 0005			      mov cx, 5                 ; Set the loop counter to the number of elements
 013F  8D 36 01EE R		      lea si, nitrogen_bases    ; Set edi to point to the start of the array

 0143				      invalid_base_loop:
 0143  C6 04 00			         mov byte ptr [si], 0          ; Zero out the current element
 0146  46			         inc si                    ; Move to the next element
 0147  E2 FA			         loop invalid_base_loop

 0149				   invalid_option:
 0149  8D 1E 01FE R		      lea   bx,errorCommandLineMsg
 014D  E8 0043			      call  printf_s
 0150  C6 06 0224 R 01		      mov	flagError,1
 0155  E9 FED1			      jmp   skip_space
				   
 0158  90			no_arguments:  NOP

 0159  8D 1E 017F R		      lea   bx,inputFile
 015D  E8 0033			      call  printf_s

 0160  8D 1E 0225 R		      lea   bx,MsgCRLF
 0164  E8 002C			      call  printf_s

 0167  8D 1E 01B1 R		      lea   bx,outputFile
 016B  E8 0025			      call  printf_s

 016E  8D 1E 0225 R		      lea   bx,MsgCRLF
 0172  E8 001E			      call  printf_s

 0175  8D 1E 01E9 R		      lea   bx,groupSize
 0179  E8 002D			      call  atoi
 017C  8B D8			      mov   bx,ax
 017E  E8 0012			      call  printf_s

 0181  8D 1E 0225 R		      lea   bx,MsgCRLF
 0185  E8 000B			      call  printf_s

 0188  8D 1E 01EE R		      lea   bx,nitrogen_bases
 018C  E8 0004			      call  printf_s

				.exit
				;
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 0193				printf_s	proc	near
 0193  8A 17				mov		dl,[bx]
 0195  80 FA 00				cmp		dl,0
 0198  74 09				je		   ps_1

 019A  53				push	   bx
 019B  B4 02				mov		ah,2
 019D  CD 21				int		21H
 019F  5B				pop		bx

 01A0  43				inc		bx		
 01A1  EB F0				jmp		printf_s
						
 01A3				ps_1:
 01A3  C3				ret
 01A4				printf_s	endp

				;
				;--------------------------------------------------------------------
				;Função Escrever um char na tela
				;		Entra: DL -> Char a ser escrito
				;--------------------------------------------------------------------
 01A4				printf_c	proc	near
 01A4  B4 02					mov		ah, 2
 01A6  CD 21					int		21H
 01A8  C3					ret
 01A9				printf_c	endp

				;
				;--------------------------------------------------------------------
				;Função:Converte um ASCII-DECIMAL para HEXA
				;Entra: (S) -> DS:BX -> Ponteiro para o string de origem
				;Sai:	(A) -> AX -> Valor "Hex" resultante
				;Algoritmo:
				;	A = 0;
				;	while (*S!='\0') {
				;		A = 10 * A + (*S - '0')
				;		++S;
				;	}
				;	return
				;--------------------------------------------------------------------
 01A9				atoi	proc near

						; A = 0;
 01A9  B8 0000					mov		ax,0
						
 01AC				atoi_2:
						; while (*S!='\0') {
 01AC  80 3F 00					cmp		byte ptr[bx], 0
 01AF  74 11					jz		   atoi_1

						; 	A = 10 * A
 01B1  B9 000A					mov		cx,10
 01B4  F7 E1					mul		cx

						; 	A = A + *S
 01B6  B5 00					mov		ch,0
 01B8  8A 0F					mov		cl,[bx]
 01BA  03 C1					add		ax,cx

						; 	A = A - '0'
 01BC  83 E8 30					sub		ax,'0'

						; 	++S
 01BF  43					inc		bx
						
						;}
 01C0  EB EA					jmp		atoi_2

 01C2				atoi_1:
						; return
 01C2  C3					ret

 01C3				atoi	endp

				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------


				end
Microsoft (R) Macro Assembler Version 6.11		    09/07/23 03:03:55
trabalho.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0228	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 01C3	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

atoi . . . . . . . . . . . . . .	P Near	 01A9	  _TEXT	Length= 001A Private
printf_c . . . . . . . . . . . .	P Near	 01A4	  _TEXT	Length= 0005 Private
printf_s . . . . . . . . . . . .	P Near	 0193	  _TEXT	Length= 0011 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
CMDCNT . . . . . . . . . . . . .	Byte	 0080	  _DATA	
CMDSTR . . . . . . . . . . . . .	Byte	 0081	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgCRLF  . . . . . . . . . . . .	Byte	 0225	  _DATA	
atoi_1 . . . . . . . . . . . . .	L Near	 01C2	  _TEXT	
atoi_2 . . . . . . . . . . . . .	L Near	 01AC	  _TEXT	
base_a . . . . . . . . . . . . .	Byte	 01F3	  _DATA	
base_check_loop  . . . . . . . .	L Near	 00E3	  _TEXT	
base_c . . . . . . . . . . . . .	Byte	 01F4	  _DATA	
base_g . . . . . . . . . . . . .	Byte	 01F6	  _DATA	
base_option  . . . . . . . . . .	L Near	 00D3	  _TEXT	
base_plus  . . . . . . . . . . .	Byte	 01F7	  _DATA	
base_t . . . . . . . . . . . . .	Byte	 01F5	  _DATA	
base_valid . . . . . . . . . . .	Byte	 01F8	  _DATA	
char_is_valid  . . . . . . . . .	L Near	 00FC	  _TEXT	
cmdline  . . . . . . . . . . . .	Byte	 0100	  _DATA	
defaultOutputFile  . . . . . . .	Byte	 01E3	  _DATA	
done_parsing_base  . . . . . . .	L Near	 013A	  _TEXT	
end_n_option . . . . . . . . . .	L Near	 00CC	  _TEXT	
errorCommandLineMsg  . . . . . .	Byte	 01FE	  _DATA	
f_option_loop  . . . . . . . . .	L Near	 006D	  _TEXT	
f_option . . . . . . . . . . . .	L Near	 005E	  _TEXT	
flagError  . . . . . . . . . . .	Byte	 0224	  _DATA	
groupSize  . . . . . . . . . . .	Byte	 01E9	  _DATA	
inputFile  . . . . . . . . . . .	Byte	 017F	  _DATA	
invalid_base_loop  . . . . . . .	L Near	 0143	  _TEXT	
invalid_base_option  . . . . . .	L Near	 013C	  _TEXT	
invalid_option . . . . . . . . .	L Near	 0149	  _TEXT	
n_option_loop  . . . . . . . . .	L Near	 00AD	  _TEXT	
n_option . . . . . . . . . . . .	L Near	 009E	  _TEXT	
next_option  . . . . . . . . . .	L Near	 003A	  _TEXT	
nitrogen_bases . . . . . . . . .	Byte	 01EE	  _DATA	
no_arguments . . . . . . . . . .	L Near	 0158	  _TEXT	
o_option_loop  . . . . . . . . .	L Near	 008D	  _TEXT	
o_option . . . . . . . . . . . .	L Near	 007E	  _TEXT	
outputFile . . . . . . . . . . .	Byte	 01B1	  _DATA	
parse_command_line . . . . . . .	L Near	 0029	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 01A3	  _TEXT	
put_a  . . . . . . . . . . . . .	L Near	 0112	  _TEXT	
put_c  . . . . . . . . . . . . .	L Near	 011A	  _TEXT	
put_g  . . . . . . . . . . . . .	L Near	 012A	  _TEXT	
put_plus . . . . . . . . . . . .	L Near	 0132	  _TEXT	
put_t  . . . . . . . . . . . . .	L Near	 0122	  _TEXT	
search_loop  . . . . . . . . . .	L Near	 00EE	  _TEXT	
skip_space . . . . . . . . . . .	L Near	 0029	  _TEXT	

	   0 Warnings
	   0 Errors
