Microsoft (R) Macro Assembler Version 6.11		    09/05/23 15:26:05
intel.asm						     Page 1 - 1


				;             Trabalho Intel
				;
				;         Eduardo Rosa   00335503

				        .model small
				        .stack

 = 000D				CR					equ		0dh
 = 000A				LF					equ		0ah
 = ".res"			FileHandleSaida		equ		".res"

 0000				        .data

 0000  0100 [			FileName				db		256 dup (?)				; Nome do arquivo a ser lido
        00
       ]
 0100  0032 [			FileNameDst				db		50	dup(0)				; Nome do arquivo a ser escrito
        00
       ]
 0132 00			FileBuffer				db		0 						; Buffer de leitura do arquivo
 0133 0000			FileHandle				dw		0						; Handler do arquivo de leitura
 0135 0000			FileHandleDst			dw		0						; Handler do arquivo de saida
 0137  0096 [			FileNameBuffer			db		150 dup (?)
        00
       ]

 01CD 4E 6F 6D 65 20 64		MsgAskFile				db		"Nome do arquivo: ", 0
       6F 20 61 72 71 75
       69 76 6F 3A 20 00
 01DF 45 72 72 6F 20 6E		ErrorOpenFileMsg		db		"Erro na abertura do arquivo.", CR, LF, 0
       61 20 61 62 65 72
       74 75 72 61 20 64
       6F 20 61 72 71 75
       69 76 6F 2E 0D 0A
       00
 01FE 45 72 72 6F 20 6E		ErrorReadFileMsg		db		"Erro na leitura do arquivo.", CR, LF, 0
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 021C 45 72 72 6F 20 6E		ErrorCreateFileMsg		db		"Erro na criacao do arquivo", CR, LF, 0
       61 20 63 72 69 61
       63 61 6F 20 64 6F
       20 61 72 71 75 69
       76 6F 0D 0A 00
 0239 45 72 72 6F 20 6E		ErrorWriteFileMsg		db		"Erro na escrita do arquivo", CR, LF, 0
       61 20 65 73 63 72
       69 74 61 20 64 6F
       20 61 72 71 75 69
       76 6F 0D 0A 00
 0256 0D 0A 00			MsgCRLF					db		CR, LF, 0

 0259 43 6F 75 6E 74 20		MsgCountA				db		"Count of 'A': ", 0
       6F 66 20 27 41 27
       3A 20 00
 0268 43 6F 75 6E 74 20		MsgCountC				db		"Count of 'C': ", 0
       6F 66 20 27 43 27
       3A 20 00
 0277 43 6F 75 6E 74 20		MsgCountT				db		"Count of 'T': ", 0
       6F 66 20 27 54 27
       3A 20 00
 0286 43 6F 75 6E 74 20		MsgCountG				db		"Count of 'G': ", 0
       6F 66 20 27 47 27
       3A 20 00

 0295 00			SomaCol1			db		0
 0296 00			SomaCol2			db		0
 0297 00			SomaCol3			db		0
 0298 00			SomaCol4			db 		0
 0299 00			Contador			db		0
 029A 0000			Contador2			dw		0
 029C 0000			TotalBytes			dw 		0
				;TODO		Fazer TotalBytes2 funcionar
 029E 00			TotalBytes2			db		0	
 029F 0030 0031 0032 0033	VetorHexa			dw		"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"
       0034 0035 0036
       0037 0038 0039
       0041 0042 0043
       0044 0045 0046
 02BF 00			FlagError				db		0
 02C0  0014 [			BufferWRWORD			db		20 dup (?)
        00
       ]
 02D4 0000			sw_n					dw		0
 02D6 00			sw_f					db		0
 02D7 0000			sw_m					dw		0
 02D9 00			BufferChar				db		0
 02DA 00			BufferPutChar				db		0

 02DB 00			A_Count     			db 		0
 02DC 00			C_Count     			db 		0
 02DD 00			T_Count     			db 		0
 02DE 00			G_Count     			db 		0
 02DF  0006 [			A_CountStr	db		6 dup (?)   ; Buffer para o contador de 'A' em formato de string
        00
       ]
 02E5  0006 [			C_CountStr	db		6 dup (?)   ; Buffer para o contador de 'C' em formato de string
        00
       ]
 02EB  0006 [			T_CountStr	db		6 dup (?)   ; Buffer para o contador de 'T' em formato de string
        00
       ]
 02F1  0006 [			G_CountStr	db		6 dup (?)   ; Buffer para o contador de 'G' em formato de string
        00
       ]

 02F7  03E8 [			commandLine db 1000 dup(?)   ; Buffer para armazenar a linha de comando
        00
       ]
 06DF  0032 [			inputFile db 50 dup(?)     ; Nome do arquivo de entrada
        00
       ]
 0711 61 2E 6F 75 74 00		outputFile db 'a.out',0       ; Nome padrão do arquivo de saída
 0717 0000			groupSize dw 0               ; Tamanho do grupo de bases
 0719  03E8 [			options db 1000 dup(?)      ; Opções da linha de comando
        00
       ]
 0B01 0000			argc dw 0                    ; Contagem de argumentos da linha de comando
 0B03 0000			argv dw 0                    ; Ponteiro para argumentos da linha de comando

 0000				        .code
				        .startup

 0017  8C D8					mov		ax,ds
 0019  8E C0					mov		es,ax

						;	Pega o nome do arquivo
 001B  E8 0118					call GetFileName

						;	Quebra a linha
 001E  8D 1E 0256 R				lea		bx,MsgCRLF
 0022  E8 013E					call	printf_s

						;	Abre o arquivo
 0025  8D 16 0000 R				lea		dx,FileName
 0029  E8 0202					call 	fopen
 002C  72 53					jc		ErrorOpenFile		;If (CF == 1), erro ao abrir o arquivo
 002E  A3 0133 R				mov		FileHandle,ax		; Salva handle do arquivo
						;	Cria o arquivo de saida
 0031  E8 020E					call	pegaNome
 0034  8D 16 0100 R				lea		dx, FileNameDst
 0038  E8 01FA					call	fcreate
 003B  72 61					jc		ErrorCreateFile
 003D  A3 0135 R				mov		FileHandleDst, ax
						
 0040				LoopReadFile:
 0040  8B 1E 0133 R		    mov bx, FileHandle
 0044  E8 018A			    call getChar
 0047  72 47			    jc  ErrorReadFile
 0049  83 F8 00			    cmp ax, 0
 004C  74 6C			    jz  CloseAndFinal
 004E  88 16 02D9 R		    mov BufferChar, dl
 0052  8A C2			    mov al, dl
				    ;call putChar
 0054  E8 011D				call printf_c
				    ; Check for 'A', 'C', 'T', 'G' and update counters
 0057  3C 41			    cmp al, 'A'
 0059  74 0E			    je  IncrementA
 005B  3C 43			    cmp al, 'C'
 005D  74 10			    je  IncrementC
 005F  3C 54			    cmp al, 'T'
 0061  74 12			    je  IncrementT
 0063  3C 47			    cmp al, 'G'
 0065  74 14			    je  IncrementG
 0067  EB D7			    jmp LoopReadFile

 0069				IncrementA:
 0069  FE 06 02DB R		    inc A_Count
 006D  EB D1			    jmp LoopReadFile

 006F				IncrementC:
 006F  FE 06 02DC R		    inc C_Count
 0073  EB CB			    jmp LoopReadFile

 0075				IncrementT:
 0075  FE 06 02DD R		    inc T_Count
 0079  EB C5			    jmp LoopReadFile

 007B				IncrementG:
 007B  FE 06 02DE R		    inc G_Count
 007F  EB BF				jmp LoopReadFile

 0081				ErrorOpenFile:
 0081  8D 1E 01DF R				lea		bx,ErrorOpenFileMsg
 0085  E8 00DB					call	printf_s
 0088  C6 06 02BF R 01				mov		FlagError,1
 008D  E9 00A2					jmp		Final

 0090				ErrorReadFile:
 0090  8D 1E 01FE R				lea		bx, ErrorReadFileMsg
 0094  E8 00CC					call	printf_s
 0097  C6 06 02BF R 01				mov		FlagError, 1
 009C  EB 1C					jmp		CloseAndFinal

 009E				ErrorCreateFile:
 009E  8D 1E 021C R				lea		bx, ErrorCreateFileMsg
 00A2  E8 00BE					call	printf_s
 00A5  C6 06 02BF R 01				mov		FlagError, 1
 00AA  EB 0E					jmp		CloseAndFinal

 00AC				ErrorWriteFile:
 00AC  8D 1E 0239 R				lea 	bx, ErrorWriteFileMsg
 00B0  E8 00B0					call	printf_s
 00B3  C6 06 02BF R 01				mov		FlagError, 1
 00B8  EB 00					jmp		CloseAndFinal

 00BA				CloseAndFinal:

				    ; Display counts of 'A', 'C', 'T', 'G'
				    ; Após incrementar cada contador (IncrementA, IncrementC, IncrementT, IncrementG), converta o valor para string

					; convert A to string
 00BA  A0 02DB R			mov al, A_Count
 00BD  BB 02DF R			mov bx, offset A_CountStr
 00C0  E8 00B6				call sprintf_w

					; convert C to string
 00C3  A0 02DC R			mov al, C_Count
 00C6  BB 02E5 R			mov bx, offset C_CountStr
 00C9  E8 00AD				call sprintf_w

					; convert T to string
 00CC  A0 02DD R			mov al, T_Count
 00CF  BB 02EB R			mov bx, offset T_CountStr
 00D2  E8 00A4				call sprintf_w

					; convert G to string
 00D5  A0 02DE R			mov al, G_Count
 00D8  BB 02F1 R			mov bx, offset G_CountStr
 00DB  E8 009B				call sprintf_w

					; Breakline
 00DE  8D 1E 0256 R			lea		bx,MsgCRLF
 00E2  E8 007E				call	printf_s

					; Print A message and A counter
 00E5  8D 1E 0259 R			lea bx, MsgCountA
 00E9  E8 0077				call printf_s
 00EC  8D 1E 02DF R			lea bx, A_CountStr
 00F0  E8 0070				call printf_s

					; Breakline
 00F3  8D 1E 0256 R			lea		bx,MsgCRLF
 00F7  E8 0069				call	printf_s

					; Print C message and C counter
 00FA  8D 1E 0268 R			lea bx, MsgCountC
 00FE  E8 0062				call printf_s
 0101  8D 1E 02E5 R			lea bx, C_CountStr
 0105  E8 005B				call printf_s

					; Breakline
 0108  8D 1E 0256 R			lea		bx,MsgCRLF
 010C  E8 0054				call	printf_s

					; Print T message and T counter
 010F  8D 1E 0277 R			lea bx, MsgCountT
 0113  E8 004D				call printf_s
 0116  8D 1E 02EB R			lea bx, T_CountStr
 011A  E8 0046				call printf_s

					; Breakline
 011D  8D 1E 0256 R			lea		bx,MsgCRLF
 0121  E8 003F				call	printf_s

					; Print G message and G counter
 0124  8D 1E 0286 R			lea bx, MsgCountG
 0128  E8 0038				call printf_s
 012B  8D 1E 02F1 R			lea bx, G_CountStr
 012F  E8 0031				call printf_s
 0132				Final:
						.exit
				;
				;--------------------------------------------------------------------
				;Funcao: Le o nome do arquivo do teclado
				;--------------------------------------------------------------------
 0136				GetFileName	proc	near
 0136  8D 1E 01CD R				lea		bx,MsgAskFile			; Coloca mensagem que pede o nome do arquivo
 013A  E8 0026					call	printf_s

 013D  B4 0A					mov		ah,0ah						; Le uma linha do teclado
 013F  8D 16 0137 R				lea		dx,FileNameBuffer
 0143  C6 06 0137 R 64				mov		byte ptr FileNameBuffer,100
 0148  CD 21					int		21h

 014A  8D 36 0139 R				lea		si,FileNameBuffer+2			; Copia do buffer de teclado para o FileName
 014E  8D 3E 0000 R				lea		di,FileName
 0152  8A 0E 0138 R				mov		cl,FileNameBuffer+1
 0156  B5 00					mov		ch,0
 0158  8C D8					mov		ax,ds						; Ajusta ES=DS para poder usar o MOVSB
 015A  8E C0					mov		es,ax
 015C  F3/ A4					rep 	movsb

 015E  26: C6 05 00				mov		byte ptr es:[di],0			; Coloca marca de fim de string
 0162  C3					ret
 0163				GetFileName	endp

				;
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 0163				printf_s	proc	near
 0163  8A 17				mov		dl,[bx]
 0165  80 FA 00				cmp		dl,0
 0168  74 09				je		ps_1

 016A  53				push	bx
 016B  B4 02				mov		ah,2
 016D  CD 21				int		21H
 016F  5B				pop		bx

 0170  43				inc		bx		
 0171  EB F0				jmp		printf_s
						
 0173				ps_1:
 0173  C3				ret
 0174				printf_s	endp

				;
				;--------------------------------------------------------------------
				;Função Escrever um char na tela
				;		Entra: DL -> Char a ser escrito
				;--------------------------------------------------------------------
 0174				printf_c	proc	near
 0174  B4 02					mov		ah, 2
 0176  CD 21					int		21H
 0178  C3					ret
 0179				printf_c	endp

				;
				;--------------------------------------------------------------------
				;Função: Converte um inteiro (n) para (string)
				;		 sprintf(string->BX, "%d", n->AX)
				;--------------------------------------------------------------------
 0179				sprintf_w	proc	near
 0179  A3 02D4 R			mov		sw_n,ax
 017C  B9 0005				mov		cx,5
 017F  C7 06 02D7 R 2710		mov		sw_m,10000
 0185  C6 06 02D6 R 00			mov		sw_f,0
					
 018A				sw_do:
 018A  BA 0000				mov		dx,0
 018D  A1 02D4 R			mov		ax,sw_n
 0190  F7 36 02D7 R			div		sw_m
					
 0194  3C 00				cmp		al,0
 0196  75 07				jne		sw_store
 0198  80 3E 02D6 R 00			cmp		sw_f,0
 019D  74 0A				je		sw_continue
 019F				sw_store:
 019F  04 30				add		al,'0'
 01A1  88 07				mov		[bx],al
 01A3  43				inc		bx
					
 01A4  C6 06 02D6 R 01			mov		sw_f,1
 01A9				sw_continue:
					
 01A9  89 16 02D4 R			mov		sw_n,dx
					
 01AD  BA 0000				mov		dx,0
 01B0  A1 02D7 R			mov		ax,sw_m
 01B3  BD 000A				mov		bp,10
 01B6  F7 F5				div		bp
 01B8  A3 02D7 R			mov		sw_m,ax
					
 01BB  49				dec		cx
 01BC  83 F9 00				cmp		cx,0
 01BF  75 C9				jnz		sw_do

 01C1  80 3E 02D6 R 00			cmp		sw_f,0
 01C6  75 05				jnz		sw_continua2
 01C8  C7 07 0030			mov		[bx],'0'
 01CC  43				inc		bx
 01CD				sw_continua2:

 01CD  C6 07 00				mov		byte ptr[bx],0
 01D0  C3				ret		
 01D1				sprintf_w	endp

				;
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   dl -> caractere
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 01D1				getChar	proc	near
 01D1  B4 3F				mov		ah,3fh
 01D3  B9 0001				mov		cx,1
 01D6  8D 16 0132 R			lea		dx,FileBuffer
 01DA  CD 21				int		21h
 01DC  8A 16 0132 R			mov		dl,FileBuffer
 01E0  C3				ret
 01E1				getChar	endp

				;
				;--------------------------------------------------------------------
				;Função recebe um char ASCII e coloca seu valor em Hexa em arquivo
				;Entra: Bx-> File Handle
				;		al-> Char ASCII
				;Sai:	CF-> 0 se deu certo
				;--------------------------------------------------------------------
 01E1				putChar	proc	near
 01E1  A2 02DA R				mov		BufferPutChar, al
 01E4  24 F0					and		al, 0f0h
						

 01E6  D0 E8					shr		al, 1
 01E8  D0 E8					shr		al, 1
 01EA  D0 E8					shr		al, 1
 01EC  D0 E8					shr		al, 1
 01EE  02 C0					add		al, al
 01F0  8D 1E 029F R				lea		bx,VetorHexa
 01F4  80 E4 00					and		ah, 0
 01F7  03 D8					add		bx, ax
 01F9  8A 17					mov		dl, [bx]
 01FB  8B 1E 0135 R				mov		bx, FileHandleDst
 01FF  E8 001C					call 	setChar
 0202  72 19					jc		ErroPutChar
						
 0204  A0 02DA R				mov		al, BufferPutChar
 0207  24 0F					and		al, 0fh
 0209  02 C0					add		al, al
 020B  8D 1E 029F R				lea		bx,VetorHexa
 020F  80 E4 00					and		ah, 0
 0212  03 D8					add		bx, ax
 0214  8A 17					mov		dl, [bx]
 0216  8B 1E 0135 R				mov		bx, FileHandleDst
 021A  E8 0001					call	setChar

 021D				ErroPutChar:
 021D  C3					ret
 021E				putChar	endp

				;
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 021E				setChar	proc	near
 021E  B4 40				mov		ah,40h
 0220  B9 0001				mov		cx,1
 0223  88 16 0132 R			mov		FileBuffer,dl
 0227  8D 16 0132 R			lea		dx,FileBuffer
 022B  CD 21				int		21h
 022D  C3				ret
 022E				setChar	endp

				;
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   AX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 022E				fopen	proc	near
 022E  B0 00				mov		al,0
 0230  B4 3D				mov		ah,3dh
 0232  CD 21				int		21h
 0234  C3				ret
 0235				fopen	endp

				;
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   AX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 0235				fcreate	proc	near
 0235  B9 0000				mov		cx,0
 0238  B4 3C				mov		ah,3ch
 023A  CD 21				int		21h
 023C  C3				ret
 023D				fcreate	endp

				;
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 023D				fclose	proc	near
 023D  B4 3E				mov		ah,3eh
 023F  CD 21				int		21h
 0241  C3				ret
 0242				fclose	endp

				;
				;--------------------------------------------------------------------
				;Função pra pegar o nome do arquivo saida
				;--------------------------------------------------------------------
 0242				pegaNome	proc	near
 0242					LoopPegaNome:
 0242  8D 1E 0000 R				lea		bx, FileName
 0246  8B 0E 029A R				mov		cx,	Contador2
 024A  03 D9					add		bx, cx
 024C  8A 07					mov		al, [bx]
 024E  3C 00					cmp		al, 0
 0250  74 16					je		FimPegaNome
 0252  3C 2E					cmp		al,	2eh
 0254  74 12					je		FimPegaNome
 0256  8D 1E 0100 R				lea		bx, FileNameDst
 025A  8B 0E 029A R				mov		cx,	Contador2
 025E  03 D9					add		bx, cx
 0260  88 07					mov		[bx], al
 0262  FF 06 029A R				inc		Contador2
 0266  EB DA					jmp		LoopPegaNome

 0268					FimPegaNome:
 0268  8D 1E 0100 R				lea		bx, FileNameDst
 026C  8B 0E 029A R				mov		cx,	Contador2
 0270  03 D9					add		bx,	cx
 0272  C7 07 002E				mov		[bx], 2eh
 0276  43					inc		bx
 0277  C7 07 0052				mov		[bx], 52h
 027B  43					inc		bx
 027C  C7 07 0065				mov		[bx], 65h
 0280  43					inc		bx
 0281  C7 07 0073				mov		[bx], 73h
 0285  C3					ret
 0286				pegaNome	endp
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
Microsoft (R) Macro Assembler Version 6.11		    09/05/23 15:26:05
intel.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0B05	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 0286	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

GetFileName  . . . . . . . . . .	P Near	 0136	  _TEXT	Length= 002D Private
fclose . . . . . . . . . . . . .	P Near	 023D	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 0235	  _TEXT	Length= 0008 Private
fopen  . . . . . . . . . . . . .	P Near	 022E	  _TEXT	Length= 0007 Private
getChar  . . . . . . . . . . . .	P Near	 01D1	  _TEXT	Length= 0010 Private
pegaNome . . . . . . . . . . . .	P Near	 0242	  _TEXT	Length= 0044 Private
printf_c . . . . . . . . . . . .	P Near	 0174	  _TEXT	Length= 0005 Private
printf_s . . . . . . . . . . . .	P Near	 0163	  _TEXT	Length= 0011 Private
putChar  . . . . . . . . . . . .	P Near	 01E1	  _TEXT	Length= 003D Private
setChar  . . . . . . . . . . . .	P Near	 021E	  _TEXT	Length= 0010 Private
sprintf_w  . . . . . . . . . . .	P Near	 0179	  _TEXT	Length= 0058 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
A_CountStr . . . . . . . . . . .	Byte	 02DF	  _DATA	
A_Count  . . . . . . . . . . . .	Byte	 02DB	  _DATA	
BufferChar . . . . . . . . . . .	Byte	 02D9	  _DATA	
BufferPutChar  . . . . . . . . .	Byte	 02DA	  _DATA	
BufferWRWORD . . . . . . . . . .	Byte	 02C0	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
C_CountStr . . . . . . . . . . .	Byte	 02E5	  _DATA	
C_Count  . . . . . . . . . . . .	Byte	 02DC	  _DATA	
CloseAndFinal  . . . . . . . . .	L Near	 00BA	  _TEXT	
Contador2  . . . . . . . . . . .	Word	 029A	  _DATA	
Contador . . . . . . . . . . . .	Byte	 0299	  _DATA	
ErroPutChar  . . . . . . . . . .	L Near	 021D	  _TEXT	
ErrorCreateFileMsg . . . . . . .	Byte	 021C	  _DATA	
ErrorCreateFile  . . . . . . . .	L Near	 009E	  _TEXT	
ErrorOpenFileMsg . . . . . . . .	Byte	 01DF	  _DATA	
ErrorOpenFile  . . . . . . . . .	L Near	 0081	  _TEXT	
ErrorReadFileMsg . . . . . . . .	Byte	 01FE	  _DATA	
ErrorReadFile  . . . . . . . . .	L Near	 0090	  _TEXT	
ErrorWriteFileMsg  . . . . . . .	Byte	 0239	  _DATA	
ErrorWriteFile . . . . . . . . .	L Near	 00AC	  _TEXT	
FileBuffer . . . . . . . . . . .	Byte	 0132	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 0135	  _DATA	
FileHandleSaida  . . . . . . . .	Text   	 ".res"
FileHandle . . . . . . . . . . .	Word	 0133	  _DATA	
FileNameBuffer . . . . . . . . .	Byte	 0137	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 0100	  _DATA	
FileName . . . . . . . . . . . .	Byte	 0000	  _DATA	
FimPegaNome  . . . . . . . . . .	L Near	 0268	  _TEXT	
Final  . . . . . . . . . . . . .	L Near	 0132	  _TEXT	
FlagError  . . . . . . . . . . .	Byte	 02BF	  _DATA	
G_CountStr . . . . . . . . . . .	Byte	 02F1	  _DATA	
G_Count  . . . . . . . . . . . .	Byte	 02DE	  _DATA	
IncrementA . . . . . . . . . . .	L Near	 0069	  _TEXT	
IncrementC . . . . . . . . . . .	L Near	 006F	  _TEXT	
IncrementG . . . . . . . . . . .	L Near	 007B	  _TEXT	
IncrementT . . . . . . . . . . .	L Near	 0075	  _TEXT	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LoopPegaNome . . . . . . . . . .	L Near	 0242	  _TEXT	
LoopReadFile . . . . . . . . . .	L Near	 0040	  _TEXT	
MsgAskFile . . . . . . . . . . .	Byte	 01CD	  _DATA	
MsgCRLF  . . . . . . . . . . . .	Byte	 0256	  _DATA	
MsgCountA  . . . . . . . . . . .	Byte	 0259	  _DATA	
MsgCountC  . . . . . . . . . . .	Byte	 0268	  _DATA	
MsgCountG  . . . . . . . . . . .	Byte	 0286	  _DATA	
MsgCountT  . . . . . . . . . . .	Byte	 0277	  _DATA	
SomaCol1 . . . . . . . . . . . .	Byte	 0295	  _DATA	
SomaCol2 . . . . . . . . . . . .	Byte	 0296	  _DATA	
SomaCol3 . . . . . . . . . . . .	Byte	 0297	  _DATA	
SomaCol4 . . . . . . . . . . . .	Byte	 0298	  _DATA	
T_CountStr . . . . . . . . . . .	Byte	 02EB	  _DATA	
T_Count  . . . . . . . . . . . .	Byte	 02DD	  _DATA	
TotalBytes2  . . . . . . . . . .	Byte	 029E	  _DATA	
TotalBytes . . . . . . . . . . .	Word	 029C	  _DATA	
VetorHexa  . . . . . . . . . . .	Word	 029F	  _DATA	
argc . . . . . . . . . . . . . .	Word	 0B01	  _DATA	
argv . . . . . . . . . . . . . .	Word	 0B03	  _DATA	
commandLine  . . . . . . . . . .	Byte	 02F7	  _DATA	
groupSize  . . . . . . . . . . .	Word	 0717	  _DATA	
inputFile  . . . . . . . . . . .	Byte	 06DF	  _DATA	
options  . . . . . . . . . . . .	Byte	 0719	  _DATA	
outputFile . . . . . . . . . . .	Byte	 0711	  _DATA	
ps_1 . . . . . . . . . . . . . .	L Near	 0173	  _TEXT	
sw_continua2 . . . . . . . . . .	L Near	 01CD	  _TEXT	
sw_continue  . . . . . . . . . .	L Near	 01A9	  _TEXT	
sw_do  . . . . . . . . . . . . .	L Near	 018A	  _TEXT	
sw_f . . . . . . . . . . . . . .	Byte	 02D6	  _DATA	
sw_m . . . . . . . . . . . . . .	Word	 02D7	  _DATA	
sw_n . . . . . . . . . . . . . .	Word	 02D4	  _DATA	
sw_store . . . . . . . . . . . .	L Near	 019F	  _TEXT	

	   0 Warnings
	   0 Errors
